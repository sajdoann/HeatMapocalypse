<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="style-worldmap.css">

    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="https://d3js.org/topojson.v0.min.js"></script>
</head>
<body>
<div id="map-container">
    <input type="range" name="mySlider" id="mySlider" min="0" max="100" step="1" value="0">
    <div id="textbox"></div>
</div>

<script>
    var width = window.innerWidth,
        height = window.innerHeight;

    var projection = d3.geo.equirectangular()
        .translate([width / 2, height / 2])
        .scale(350);

    var svg = d3.select("#map-container").append("svg")
        .attr("width", width)
        .attr("height", height);

    var path = d3.geo.path()
        .projection(projection);

    var g = svg.append("g");

    // Define the color scale
    var colorScale = d3.scale.linear()
        .domain([0, 30])
        .range(["blue", "red"]);

    // load and display the World
    d3.json("world-110m2.json", function (error, topology) {
        var slider = d3.select("#mySlider");
        var textbox = d3.select("#textbox");

        // load and display the cities
        d3.csv("samplepoints.csv", function (error, data) {
            slider.on("input", function () {
                var value = +this.value;
                var year = Math.floor(value / 12) + 1743;
                var month = (value % 12) + 1;
                var monthString = ("0" + month).slice(-2);
                var selectedYearMonth = year + "-" + monthString;
                textbox.text("Year: " + year + ", Month: " + month).style("color", "black");

                // Filter the data based on the selected year and month
                var filteredData = data.filter(function (d) {
                    return d.yearmonth === selectedYearMonth;
                });

                // Update the data binding for the circles
                var circles = g.selectAll("circle").data(filteredData);

                circles.enter()
                    .append("a")
                    .attr("xlink:href", function(d) {
                        return "https://www.google.com/search?q=" + d.City;
                    })
                    .append("circle")
                    .attr("cx", function (d) {
                        return projection([d.lon, d.lat])[0];
                    })
                    .attr("cy", function (d) {
                        return projection([d.lon, d.lat])[1];
                    })
                    .attr("r", 5)
                    .style("opacity", 0.5)
                    .style("fill", function (d) {
                        return colorScale(+d.AverageTemperature);
                    });

                circles.exit().remove();

                // Update the existing circles' positions
                g.selectAll("circle")
                    .data(filteredData)
                    .attr("cx", function(d) {
                        return projection([d.lon, d.lat])[0];
                    })
                    .attr("cy", function(d) {
                        return projection([d.lon, d.lat])[1];
                    })
                    .style("fill", function(d) {
                        return colorScale(+d.AverageTemperature);
                    });
            });

            // Initialize with the default values
            slider.dispatch("input");
        });

        g.selectAll("path")
            .data(topojson.object(topology, topology.objects.countries).geometries)
            .enter()
            .append("path")
            .attr("d", path);
    });
</script>
</body>
</html>
